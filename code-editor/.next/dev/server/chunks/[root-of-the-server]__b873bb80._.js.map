{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///Users/natleo/Desktop/online-code-editor/code-editor/app/api/run/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { spawn } from \"child_process\";\nimport fs from \"fs/promises\";\nimport os from \"os\";\nimport path from \"path\";\n\nexport const runtime = \"nodejs\";\n\ntype RunBody = {\n  language: string;\n  code: string;\n  input: string;   // full raw text from UI\n};\n\nconst PY_UTILS = `\nimport re, json, ast\nfrom typing import Any, List\n\ndef smart_parse_scalar(token: str) -> Any:\n    token = token.strip()\n    if token == \"\":\n        return token\n\n    # bool\n    if token.lower() == \"true\":\n        return True\n    if token.lower() == \"false\":\n        return False\n\n    # int\n    try:\n        i = int(token)\n        return i\n    except ValueError:\n        pass\n\n    # float\n    try:\n        f = float(token)\n        return f\n    except ValueError:\n        pass\n\n    # JSON / Python literal (lists, dicts, tuples, etc.)\n    if (token.startswith(\"{\") and token.endswith(\"}\")) or \\\n       (token.startswith(\"[\") and token.endswith(\"]\")) or \\\n       (token.startswith(\"(\") and token.endswith(\")\")):\n        try:\n            return json.loads(token)\n        except Exception:\n            try:\n                return ast.literal_eval(token)\n            except Exception:\n                pass\n\n    return token\n\ndef smart_parse_lines(raw: str) -> List[Any]:\n    lines = [ln for ln in raw.strip().splitlines() if ln.strip() != \"\"]\n    return [smart_parse_scalar(ln) for ln in lines]\n\ndef parse_int_list(line: str) -> List[int]:\n    return [int(x) for x in line.strip().split() if x.strip()]\n\ndef parse_int_matrix(raw: str) -> List[List[int]]:\n    lines = [ln for ln in raw.strip().splitlines() if ln.strip()]\n    return [parse_int_list(ln) for ln in lines]\n`;\n\nexport async function POST(req: NextRequest) {\n  let body: RunBody;\n\n  try {\n    body = await req.json();\n  } catch {\n    return NextResponse.json(\n      { detail: \"Invalid JSON body\" },\n      { status: 400 }\n    );\n  }\n\n  const { language, code, input } = body;\n\n  if (language !== \"python\") {\n    return NextResponse.json(\n      { detail: \"Only python supported in this MVP\" },\n      { status: 400 }\n    );\n  }\n\n  const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), \"code-run-\"));\n  const scriptPath = path.join(tmpDir, \"main.py\");\n\n  const scriptContent = `\nimport sys, json, ast\nfrom typing import Any, List\n\ndef parse_line_to_list(line: str) -> List[Any]:\n    s = line.strip()\n    if not s:\n        return []\n\n    # 1) Try JSON / Python list literal on the whole line\n    if (s.startswith(\"[\") and s.endswith(\"]\")) or (s.startswith(\"(\") and s.endswith(\")\")):\n        # eg: \"[1,2,3]\" or \"(1,2,3)\"\n        try:\n            v = json.loads(s)\n            if isinstance(v, list):\n                return v\n        except Exception:\n            try:\n                v = ast.literal_eval(s)\n                if isinstance(v, list):\n                    return v\n                if isinstance(v, tuple):\n                    return list(v)\n            except Exception:\n                pass\n\n    # 2) Fallback: split by commas / whitespace and parse scalars\n    s = s.replace(\",\", \" \")\n    parts = [p for p in s.split() if p.strip()]\n\n    result: List[Any] = []\n    for tok in parts:\n        t = tok.strip()\n\n        # try int\n        try:\n            result.append(int(t))\n            continue\n        except ValueError:\n            pass\n\n        # try float\n        try:\n            result.append(float(t))\n            continue\n        except ValueError:\n            pass\n\n        # fallback: string\n        result.append(t)\n\n    return result\n\ndef parse_lines_to_lists(raw: str) -> List[List[Any]]:\n    lines = [ln for ln in raw.splitlines() if ln.strip()]\n    return [parse_line_to_list(ln) for ln in lines]\n\n${code}\n\nif __name__ == \"__main__\":\n    import traceback\n    raw = sys.stdin.read()\n    lines = [ln for ln in raw.splitlines() if ln.strip()]\n    sol = Solution()\n    for ln in lines:\n        try:\n            nums = parse_line_to_list(ln)\n            result = sol.solution(nums)\n            # Print each result on its own line\n            print(result)\n        except Exception:\n            # Show the error but keep going for other lines\n            traceback.print_exc()\n`;\n\n\n  await fs.writeFile(scriptPath, scriptContent, \"utf-8\");\n\n  try {\n    const child = spawn(\"python3\", [scriptPath], {\n      cwd: tmpDir,\n      env: {\n        ...process.env,\n        PYTHONUNBUFFERED: \"1\",\n      },\n    });\n\n    let stdout = \"\";\n    let stderr = \"\";\n\n    child.stdout.on(\"data\", (chunk) => {\n      stdout += chunk.toString();\n    });\n\n    child.stderr.on(\"data\", (chunk) => {\n      stderr += chunk.toString();\n    });\n\n    // full raw input from UI\n    child.stdin.write(input || \"\");\n    child.stdin.end();\n\n    const timeoutMs = 3000;\n    const timeout = setTimeout(() => {\n      child.kill(\"SIGKILL\");\n    }, timeoutMs);\n\n    const exitCode: number = await new Promise((resolve) => {\n      child.on(\"close\", (code) => {\n        clearTimeout(timeout);\n        resolve(code ?? 0);\n      });\n    });\n\n    return NextResponse.json(\n      {\n        stdout,\n        stderr,\n        exitCode,\n      },\n      { status: 200 }\n    );\n  } catch (err: any) {\n    return NextResponse.json(\n      { detail: err.message || \"Execution error\" },\n      { status: 500 }\n    );\n  } finally {\n    fs.rm(tmpDir, { recursive: true, force: true }).catch(() => {});\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEO,MAAM,UAAU;AAQvB,MAAM,WAAW,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDlB,CAAC;AAEM,eAAe,KAAK,GAAgB;IACzC,IAAI;IAEJ,IAAI;QACF,OAAO,MAAM,IAAI,IAAI;IACvB,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,QAAQ;QAAoB,GAC9B;YAAE,QAAQ;QAAI;IAElB;IAEA,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG;IAElC,IAAI,aAAa,UAAU;QACzB,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,QAAQ;QAAoC,GAC9C;YAAE,QAAQ;QAAI;IAElB;IAEA,MAAM,SAAS,MAAM,gIAAE,CAAC,OAAO,CAAC,4GAAI,CAAC,IAAI,CAAC,wGAAE,CAAC,MAAM,IAAI;IACvD,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,QAAQ;IAErC,MAAM,gBAAgB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDzB,EAAE,KAAK;;;;;;;;;;;;;;;;AAgBP,CAAC;IAGC,MAAM,gIAAE,CAAC,SAAS,CAAC,YAAY,eAAe;IAE9C,IAAI;QACF,MAAM,QAAQ,IAAA,4HAAK,EAAC,WAAW;YAAC;SAAW,EAAE;YAC3C,KAAK;YACL,KAAK;gBACH,GAAG,QAAQ,GAAG;gBACd,kBAAkB;YACpB;QACF;QAEA,IAAI,SAAS;QACb,IAAI,SAAS;QAEb,MAAM,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC;YACvB,UAAU,MAAM,QAAQ;QAC1B;QAEA,MAAM,MAAM,CAAC,EAAE,CAAC,QAAQ,CAAC;YACvB,UAAU,MAAM,QAAQ;QAC1B;QAEA,yBAAyB;QACzB,MAAM,KAAK,CAAC,KAAK,CAAC,SAAS;QAC3B,MAAM,KAAK,CAAC,GAAG;QAEf,MAAM,YAAY;QAClB,MAAM,UAAU,WAAW;YACzB,MAAM,IAAI,CAAC;QACb,GAAG;QAEH,MAAM,WAAmB,MAAM,IAAI,QAAQ,CAAC;YAC1C,MAAM,EAAE,CAAC,SAAS,CAAC;gBACjB,aAAa;gBACb,QAAQ,QAAQ;YAClB;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE;YACA;YACA;QACF,GACA;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,KAAU;QACjB,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,QAAQ,IAAI,OAAO,IAAI;QAAkB,GAC3C;YAAE,QAAQ;QAAI;IAElB,SAAU;QACR,gIAAE,CAAC,EAAE,CAAC,QAAQ;YAAE,WAAW;YAAM,OAAO;QAAK,GAAG,KAAK,CAAC,KAAO;IAC/D;AACF"}}]
}